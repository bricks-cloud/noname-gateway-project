commit 32cb7220f7a1dd09a9ae8cf2444b59cf8ed2f676
Author: Poome Thavornvanit <pthavorn@pthavorn-mn3.linkedin.biz>
Date:   Sun Jun 26 12:56:47 2022 -0400

    Building CUE compiler to read CUE config files and encode into Go Schemas

diff --git a/cue/bricks/client.cue b/cue/bricks/client.cue
index 750eab6..dc8ebc8 100644
--- a/cue/bricks/client.cue
+++ b/cue/bricks/client.cue
@@ -1,45 +1,78 @@
 package bricks
 
-#Client: {
-	$bricks: type: _name: "Client"
+// #Client: {
+// 	$bricks: type: _name: "Client"
+// 	name: string
+// }
+
+// #Resource: {
+// 	$bricks: type: _name: "Resource"
+// 	name: string
+// }
+
+// spotifyClient: #Client & {
+// 	name: "spotifyClientNameBLahblah"
+// }
+
+#service: {
 	name: string
+	description?: string
+	url: string
+	// routes: [...#route]
 }
 
-#Resource: {
-	$bricks: type: _name: "Resource"
+#route: {
 	name: string
+	description?: string
+	paths: [...string]
 }
 
-// Vanguard is a data monitor alerting system for SQL databses
-#VanguardClient: #Client & {
-	source:       "BigQuery"
-	name:         "VanguardClient"
-	alertChannel: "Webhook"
-
-	// credentials
-	credentials: {
-		if *source == "BigQuery" {
-			serviceAccountKey: string
-		}
-	}
-
-	if *alertChannel == "Webhook" {
-		webhookURL: =~"https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)"
-	}
+config: #service & {
+    name: "my-service"
+    description: "mock description for service"
+    url: "sample.com/my-service"
+    // routes: [
+    //     { 
+    //     name: "my-first-route"
+    //     paths: ["/first", "/route"]
+    //     },
+    //     {
+    //     name: "my-second-route"
+    //     paths: ["/home"]
+    //     }
+    // ]
 }
 
+// Vanguard is a data monitor alerting system for SQL databses
+// #VanguardClient: #Client & {
+// 	source:       "BigQuery"
+// 	name:         "VanguardClient"
+// 	alertChannel: "Webhook"
+
+// 	// credentials
+// 	credentials: {
+// 		if *source == "BigQuery" {
+// 			serviceAccountKey: string
+// 		}
+// 	}
+
+// 	if *alertChannel == "Webhook" {
+// 		webhookURL: =~"https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)"
+// 	}
+// }
+
 // DataQualityAlert is a periodically running SQL scheduled job
 // that detects data quality anomalies when it happens
-#DataQualityAlert: #Resource & {
-	name: "DataQualityAlert"
+// #DataQualityAlert: #Resource & {
+// 	name: "DataQualityAlert"
 
-	// schedule shoud be in unix cron tab format
-	schedule: =~"/^(\\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|\\*\\/([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\\*|([0-9]|1[0-9]|2[0-3])|\\*\\/([0-9]|1[0-9]|2[0-3])) (\\*|([1-9]|1[0-9]|2[0-9]|3[0-1])|\\*\\/([1-9]|1[0-9]|2[0-9]|3[0-1])) (\\*|([1-9]|1[0-2])|\\*\\/([1-9]|1[0-2])) (\\*|([0-6])|\\*\\/([0-6]))$/"
+// 	// schedule shoud be in unix cron tab format
+// 	schedule: =~"/^(\\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|\\*\\/([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\\*|([0-9]|1[0-9]|2[0-3])|\\*\\/([0-9]|1[0-9]|2[0-3])) (\\*|([1-9]|1[0-9]|2[0-9]|3[0-1])|\\*\\/([1-9]|1[0-9]|2[0-9]|3[0-1])) (\\*|([1-9]|1[0-2])|\\*\\/([1-9]|1[0-2])) (\\*|([0-6])|\\*\\/([0-6]))$/"
 
-	sqlQuery:  string
-	condition: "=" | "<" | ">" | ">=" | "<="
-	threshold: int | string | bool
-}
+// 	sqlQuery:  string
+// 	condition: "=" | "<" | ">" | ">=" | "<="
+// 	threshold: int | string | bool
+// }
 
 // #Deployment: {
 // 	$bricks: type: _name: "Deployment"
diff --git a/main.go b/main.go
index 335ac64..fdc49fd 100644
--- a/main.go
+++ b/main.go
@@ -2,30 +2,128 @@ package main
 
 import (
 	"fmt"
-	"log"
-	"os"
-	"os/exec"
-	"path/filepath"
 
 	example "github.com/bricks-cloud/bricks/commons"
-	hclog "github.com/hashicorp/go-hclog"
 	plugin "github.com/hashicorp/go-plugin"
+
+	"cuelang.org/go/cue/cuecontext"
+	"cuelang.org/go/cue/load"
 )
 
-// func main() {
-// 	v, err := compiler.Build(context.Background(), "./cue/bricks", nil)
-// 	if err != nil {
-// 		fmt.Println(err)
-// 	}
+type Service struct {
+	name        string `cue:"name"`
+	description string `cue:"description"`
+	url         string `cue:"url"`
+	// Routes      []Route `json:"routes"`
+}
+
+type Route struct {
+	name        string
+	description string
+	paths       []string
+}
 
-// 	controller := flow.New(&flow.Config{
-// 		FindHiddenTasks: true,
-// 	}, v.Cue(), ioTaskFunc)
+func main() {
 
-// 	if err := controller.Run(context.Background()); err != nil {
-// 		fmt.Println(err)
-// 	}
-// }
+	// We need a cue.Context, the New'd return is ready to use
+	ctx := cuecontext.New()
+
+	// The entrypoints are the same as the files you'd specify at the command line
+	entrypoints := []string{"./cue/bricks/client.cue"}
+
+	// Load Cue files into Cue build.Instances slice
+	// the second arg is a configuration object, we'll see this later
+	bis := load.Instances(entrypoints, nil)
+
+	// Loop over the instances, checking for errors and printing
+	for _, bi := range bis {
+		// check for errors on the instance
+		// these are typically parsing errors
+		if bi.Err != nil {
+			fmt.Println("Error during load:", bi.Err)
+			continue
+		}
+
+		// Use cue.Context to turn build.Instance to cue.Instance
+		value := ctx.BuildInstance(bi)
+		if value.Err() != nil {
+			fmt.Println("Error during build:", value.Err())
+			continue
+		}
+
+		// print the error
+		fmt.Println("root value:", value)
+
+		myService := &Service{}
+		_ = value.Decode(myService)
+		fmt.Println("myService...", myService)
+
+		// var myService *Service
+		// myService = new(Service)
+		// fmt.Println(value.Decode(&myService))
+		// fmt.Println(myService)
+
+		// Validate the value
+		err := value.Validate()
+		if err != nil {
+			fmt.Println("Error during validate:", err)
+			continue
+		}
+	}
+
+	// Loads cue file into go
+	// v, err := compiler.Build(context.Background(), "./cue/bricks", nil)
+	// if err != nil {
+	// 	fmt.Println(err)
+	// }
+
+	// taken from cue docs...
+	// 	const config = `
+	// msg:   "Hello \(place)!"
+	// place: string | *"world" // "world" is the default.
+	// `
+	// 	var r cue.Runtime
+
+	// 	instance, _ := r.Compile("test", config)
+
+	// 	str, _ := instance.Lookup("msg").String()
+
+	// 	fmt.Println(str)
+
+	// 	type ab struct{ A, B int }
+
+	// 	var x ab
+
+	// 	i, _ := r.Compile("test", `{A: 2, B: 4}`)
+	// 	_ = i.Value().Decode(&x)
+	// 	fmt.Println(x)
+
+	// 	i, _ = r.Compile("test", `{B: "foo"}`)
+	// 	_ = i.Value().Decode(&x)
+	// 	fmt.Println(x)
+
+	// way 1
+	// var myService *Service
+	// myService = new(Service)
+	// fmt.Println(v.Decode(&myService))
+	// fmt.Println(myService)
+
+	// another way 2
+	// var myService Service
+	// _ = v.Decode(&myService)
+	// fmt.Println(myService)
+
+	// Use the loaded files and turn into go shemas ...
+	// ...
+
+	// controller := flow.New(&flow.Config{
+	// 	FindHiddenTasks: true,
+	// }, v.Cue(), ioTaskFunc)
+
+	// if err := controller.Run(context.Background()); err != nil {
+	// 	fmt.Println(err)
+	// }
+}
 
 // func ioTaskFunc(flowVal cue.Value) (flow.Runner, error) {
 // 	v := compiler.Wrap(flowVal)
@@ -34,7 +132,7 @@ import (
 // 		cue.Str("spotifyClient"),
 // 		cue.Str("$bricks"),
 // 		cue.Str("type"),
-// 		cue.Hid("_resourceName", "github.com/bricks-cloud/bricks/cue/bricks")),
+// 		cue.Hid("_name", "github.com/bricks-cloud/bricks/cue/bricks")),
 // 	)
 
 // 	if typ.Exists() {
@@ -46,66 +144,66 @@ import (
 // 	}), nil
 // }
 
-func main() {
+// func main() {
 
-	// Create an hclog.Logger
-	logger := hclog.New(&hclog.LoggerOptions{
-		Name:   "plugin",
-		Output: os.Stdout,
-		Level:  hclog.Debug,
-	})
+// 	// Create an hclog.Logger
+// 	logger := hclog.New(&hclog.LoggerOptions{
+// 		Name:   "plugin",
+// 		Output: os.Stdout,
+// 		Level:  hclog.Debug,
+// 	})
 
-	path, err := os.Getwd()
-	if err != nil {
-		log.Fatal(err)
-	}
+// 	path, err := os.Getwd()
+// 	if err != nil {
+// 		log.Fatal(err)
+// 	}
 
-	pluginFolder := "plugin"
-	pluginBuildPath := filepath.Join(path, pluginFolder, "plugin_tmp")
-	excutable := "greeter"
-	excutablePath := filepath.Join(pluginBuildPath, excutable)
+// 	pluginFolder := "plugin"
+// 	pluginBuildPath := filepath.Join(path, pluginFolder, "plugin_tmp")
+// 	excutable := "greeter"
+// 	excutablePath := filepath.Join(pluginBuildPath, excutable)
 
-	if err = os.Mkdir(pluginBuildPath, os.ModePerm); err != nil {
-		log.Fatal(err)
-	}
+// 	if err = os.Mkdir(pluginBuildPath, os.ModePerm); err != nil {
+// 		log.Fatal(err)
+// 	}
 
-	cmd := exec.Command("go", "build", "-o", excutablePath)
-	cmd.Dir = filepath.Join(path, pluginFolder)
-	if err := cmd.Run(); err != nil {
-		log.Fatal(err)
-	}
+// 	cmd := exec.Command("go", "build", "-o", excutablePath)
+// 	cmd.Dir = filepath.Join(path, pluginFolder)
+// 	if err := cmd.Run(); err != nil {
+// 		log.Fatal(err)
+// 	}
 
-	// We're a host! Start by launching the plugin process.
-	client := plugin.NewClient(&plugin.ClientConfig{
-		HandshakeConfig: handshakeConfig,
-		Plugins:         pluginMap,
-		Cmd:             exec.Command(excutablePath),
-		Logger:          logger,
-	})
-	defer client.Kill()
-
-	// Connect via RPC
-	rpcClient, err := client.Client()
-	if err != nil {
-		log.Fatal(err)
-	}
+// 	// We're a host! Start by launching the plugin process.
+// 	client := plugin.NewClient(&plugin.ClientConfig{
+// 		HandshakeConfig: handshakeConfig,
+// 		Plugins:         pluginMap,
+// 		Cmd:             exec.Command(excutablePath),
+// 		Logger:          logger,
+// 	})
+// 	defer client.Kill()
+
+// 	// Connect via RPC
+// 	rpcClient, err := client.Client()
+// 	if err != nil {
+// 		log.Fatal(err)
+// 	}
 
-	// Request the plugin
-	raw, err := rpcClient.Dispense("greeter")
-	if err != nil {
-		log.Fatal(err)
-	}
+// 	// Request the plugin
+// 	raw, err := rpcClient.Dispense("greeter")
+// 	if err != nil {
+// 		log.Fatal(err)
+// 	}
 
-	// We should have a Greeter now! This feels like a normal interface
-	// implementation but is in fact over an RPC connection.
-	greeter := raw.(example.Greeter)
-	fmt.Println(greeter.Greet())
+// 	// We should have a Greeter now! This feels like a normal interface
+// 	// implementation but is in fact over an RPC connection.
+// 	greeter := raw.(example.Greeter)
+// 	fmt.Println(greeter.Greet())
 
-	err = os.RemoveAll(pluginBuildPath)
-	if err != nil {
-		log.Fatal(err)
-	}
-}
+// 	err = os.RemoveAll(pluginBuildPath)
+// 	if err != nil {
+// 		log.Fatal(err)
+// 	}
+// }
 
 // handshakeConfigs are used to just do a basic handshake between
 // a plugin and host. If the handshake fails, a user friendly error is shown.
